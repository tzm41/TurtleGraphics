% Use this template to write your solutions to COS 423 problem sets

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsfonts, amsthm, amssymb, algorithm, graphicx, mathtools, xfrac}
\usepackage[noend]{algpseudocode}
\usepackage{fancyhdr, lastpage}
\usepackage[vmargin=1.20in,hmargin=1.25in,centering,letterpaper]{geometry}
\setlength{\headsep}{.50in}
\setlength{\headheight}{15pt}

% Landau notation
\DeclareMathOperator{\BigOm}{\mathcal{O}}
\newcommand{\BigOh}[1]{\BigOm\left({#1}\right)}
\DeclareMathOperator{\BigTm}{\Theta}
\newcommand{\BigTheta}[1]{\BigTm\left({#1}\right)}
\DeclareMathOperator{\BigWm}{\Omega}
\newcommand{\BigOmega}[1]{\BigWm\left({#1}\right)}
\DeclareMathOperator{\LittleOm}{\mathrm{o}}
\newcommand{\LittleOh}[1]{\LittleOm\left({#1}\right)}
\DeclareMathOperator{\LittleWm}{\omega}
\newcommand{\LittleOmega}[1]{\LittleWm\left({#1}\right)}

% argmin and argmax
\newcommand{\argmin}{\operatornamewithlimits{argmin}}
\newcommand{\argmax}{\operatornamewithlimits{argmax}}

\newcommand{\calP}{\mathcal{P}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Exp}{\mathbb{E}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\sign}{\mathrm{sign\ }}
\newcommand{\abs}{\mathrm{abs\ }}
\newcommand{\eps}{\varepsilon}
\newcommand{\zo}{\{0, 1\}}
\newcommand{\SAT}{\mathit{SAT}}
\renewcommand{\P}{\mathbf{P}}
\newcommand{\NP}{\mathbf{NP}}
\newcommand{\coNP}{\co{NP}}
\newcommand{\co}[1]{\mathbf{co#1}}
\renewcommand{\Pr}{\mathop{\mathrm{Pr}}}

% theorems, lemmas, invariants, etc.
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{invariant}[theorem]{Invariant}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{property}[theorem]{Property}
\newtheorem{proposition}[theorem]{Proposition}

% piecewise functions
\newenvironment{piecewise}{\left \{\begin{array}{l@{,\ }l}}
{\end{array}\right.}

% paired delimiters
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\len}{|}{|}
\DeclarePairedDelimiter{\set}{\{}{\}}

\makeatletter
\@addtoreset{equation}{section}
\makeatother
\renewcommand{\theequation}{\arabic{section}.\arabic{equation}}

% algorithms
\algnewcommand\algorithmicinput{\textbf{INPUT:}}
\algnewcommand\INPUT{\item[\algorithmicinput]}
\algnewcommand\algorithmicoutput{\textbf{OUTPUT:}}
\algnewcommand\OUTPUT{\item[\algorithmicoutput]}


% Formating Macros

\pagestyle{fancy}
\lhead{\sc \hmwkClass\ $\; \;\cdot \; \;$ \hmwkSemester\ $\; \;\cdot \; \;$
Problem \hmwkAssignmentNum.\hmwkProblemNum}
%\chead{\sc Problem \hmwkAssignmentNum.\hmwkProblemNum}
%\chead{}
\rhead{\em \hmwkAuthorName\ $($\hmwkAuthorID$)$\/}
\cfoot{}
\lfoot{}
\rfoot{\sc Page\ \thepage\ of\ \protect\pageref{LastPage}}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\fancypagestyle{fancycollab}
{
    %\lfoot{\textit{Collaborators: \hmwkCollaborators}}
}

\fancypagestyle{problemstatement}
{
    \rhead{}
    \lfoot{}
}

%%%%%% Begin document with header and title %%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%% Header Information %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Shouldn't need to change these
\newcommand{\hmwkClass}{CSCI 255}
\newcommand{\hmwkSemester}{Spring 2016}

%%% Your name, in standard First Last format
\newcommand{\hmwkAuthorName}{Zhuoming Tan}
%%% Your NetID
\newcommand{\hmwkAuthorID}{ztan}

%%% The problem set number (just the number)
\newcommand{\hmwkAssignmentNum}{2}

%%% The problem number (just the number)
\newcommand{\hmwkProblemNum}{1}

%%% A list of your collaborators' NetIDs, separated by ", ".
%%% You can use a new line ("\\") in the middle to prevent a long
%%% list from overflowing.
\newcommand{\hmwkCollaborators}{Rafeal Zuniga}
%%% Sets the collaborator list to appear on the first page
\thispagestyle{fancycollab}

%%%%%%% begin Solution %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%% begin Problem %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Turtle Graphics}
In millions of newspapers across the United States there is a word game called \textit{Jumble}. The object of this game is to solve a riddle, but in order to find the letters that appear in the answer it is necessary to unscramble four words. Your task is to write a program that can unscramble words.

\bigskip

\noindent\textbf{Input}

The input file contains four parts:
\begin{enumerate}
  \item a dictionary, which consists of at least one and at most 100 words, one per line;
  \item a line containing \texttt{XXXXXX}, which signals the end of the dictionary;
  \item one or more scrambled `words' that you must unscramble, each on a line by itself; and
  \item another line containing \texttt{XXXXXX}, which signals the end of the file.
\end{enumerate}
All words, including both dictionary words and scrambled words, consist only of lowercase English letters and will be at least one and at most six characters long. (Note that the sentinel \texttt{XXXXXX} contains uppercase \texttt{X}'s.) The dictionary is not necessarily in sorted order, but each word in the dictionary is unique.

\bigskip

\noindent\textbf{Output}

For each scrambled word in the input, output an alphabetical list of all dictionary words that can be formed by rearranging the letters in the scrambled word. Each word in this list must appear on a line by itself. If the list is empty (because no dictionary words can be formed), output the line ``\texttt{NOT A VALID WORD}'' instead. In either case, output a line containing six asterisks to signal the end of the list.

%%%%%%% end Problem %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Formulation}
Upon consideration, there will be two arrays at scanning phase, storing the dictonary and the scrambled words. We could sort each of the strings in alphabetical order, store them in two other arrays, and compare the sorted versions.

The sorting time of each word is relatively small, on average $l\log l$ time, where the length of each word $l\leq6$ could be treated as constant. So the total time is $m+n$, the sum of the two lists. The comparing time of the whole list is then $m\times n$, where each of the provided words in the list of length $m$, has to be compared to the words in the dictionary of length $n$.

\section{Solution}

Our algorithm consists of two phases: in the \textit{scanning phase}, we scan in all the dictionary and scrambled words, and sort each word in alphabetical order; in the \textit{comparing phase} we check if the sorted words in the words list match those in the dictionary list, and output the corresponding words in the dictionary before the sorting.

The scanning phase maintains two lists of the words, the dictionary and the scrambled words. It then sorts the two lists into sorted versions.

The comparing phase simply compares each of the sorted scrambled words with each of the sorted dictonary words.

\begin{algorithm}[H]
  \caption{Scanning Words}
  \begin{algorithmic}
    \Procedure{Scan}{$M,N$}
      \State $L_1,L_2,L_3 \gets$ \Call{MakeList}{}
      \While{$m$ of next line is not \texttt{XXXXXX}}
          \State $L_1$.\Call{add}{$m$}
      \EndWhile
      \While{$n$ of next line is not \texttt{XXXXXX}}
          \State $L_2$.\Call{add}{$n$}
      \EndWhile
      \State $L_3 \gets$ \Call{Arrays.Sort}{$L_1$}
      \State $L_2 \gets$ \Call{Arrays.Sort}{$L_2$}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

We now compare the sorted versions of the words.

\begin{algorithm}[H]
  \caption{Verifying Words}
  \begin{algorithmic}
    \Procedure{Verify}{$L_2,L_3$}
      \For{$n \in L_2$}
        \For{$i$ from 0 to $m$}
          \If{$n=L_3$.\Call{Get}{$i$}}
            \State \Return $L_1$.\Call{Get}{$i$}
          \Else
            \State \Return \texttt{NOT A VALID WORD}
          \EndIf
        \EndFor
        \State \Return \texttt{******}
      \EndFor
      \State \Return null
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\section{Correctness}

\begin{proposition}
The algorithm either outputs the matched dictionary words (if there exist) or reports that there is none.
\end{proposition}

\begin{proof}
During the scanning phase, we maintained that the program holds three lists, the alphabetical sorted version of the dictionary, the scrambled words, and the original dictionary. Upon comparison of the two sorted lists, we know that any match will indicate an anagram, thus pointing out a positive hit in the dictionary, of the same index.
\end{proof}

\section{Analysis}

\begin{proposition}
\label{numq}
The scan-and-verify algorithm makes $m\times n$ calls to String comparison.
\end{proposition}

\begin{proof}
There are $n$ elements in the scrambled words list, each of them requiring $m$ comparison to each of the words in the dictionary.
\end{proof}


\section{A Verdict from UVa}

Here we attach a screenshot of an accepted submission to the UVa OJ.\@

\begin{figure}[H]
  \includegraphics[width=\textwidth]{OJ}
\end{figure}

%%%%%%% end Solution %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
