% Use this template to write your solutions to COS 423 problem sets

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsfonts, amsthm, amssymb, algorithm, graphicx, mathtools, xfrac}
\usepackage[noend]{algpseudocode}
\usepackage{fancyhdr, lastpage}
\usepackage[vmargin=1.20in,hmargin=1.25in,centering,letterpaper]{geometry}
\setlength{\headsep}{.50in}
\setlength{\headheight}{15pt}

% Landau notation
\DeclareMathOperator{\BigOm}{\mathcal{O}}
\newcommand{\BigOh}[1]{\BigOm\left({#1}\right)}
\DeclareMathOperator{\BigTm}{\Theta}
\newcommand{\BigTheta}[1]{\BigTm\left({#1}\right)}
\DeclareMathOperator{\BigWm}{\Omega}
\newcommand{\BigOmega}[1]{\BigWm\left({#1}\right)}
\DeclareMathOperator{\LittleOm}{\mathrm{o}}
\newcommand{\LittleOh}[1]{\LittleOm\left({#1}\right)}
\DeclareMathOperator{\LittleWm}{\omega}
\newcommand{\LittleOmega}[1]{\LittleWm\left({#1}\right)}

% argmin and argmax
\newcommand{\argmin}{\operatornamewithlimits{argmin}}
\newcommand{\argmax}{\operatornamewithlimits{argmax}}

\newcommand{\calP}{\mathcal{P}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Exp}{\mathbb{E}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\sign}{\mathrm{sign\ }}
\newcommand{\abs}{\mathrm{abs\ }}
\newcommand{\eps}{\varepsilon}
\newcommand{\zo}{\{0, 1\}}
\newcommand{\SAT}{\mathit{SAT}}
\renewcommand{\P}{\mathbf{P}}
\newcommand{\NP}{\mathbf{NP}}
\newcommand{\coNP}{\co{NP}}
\newcommand{\co}[1]{\mathbf{co#1}}
\renewcommand{\Pr}{\mathop{\mathrm{Pr}}}

% theorems, lemmas, invariants, etc.
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{invariant}[theorem]{Invariant}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{property}[theorem]{Property}
\newtheorem{proposition}[theorem]{Proposition}

% piecewise functions
\newenvironment{piecewise}{\left \{\begin{array}{l@{,\ }l}}
{\end{array}\right.}

% paired delimiters
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\len}{|}{|}
\DeclarePairedDelimiter{\set}{\{}{\}}

\makeatletter
\@addtoreset{equation}{section}
\makeatother
\renewcommand{\theequation}{\arabic{section}.\arabic{equation}}

% algorithms
\algnewcommand\algorithmicinput{\textbf{INPUT:}}
\algnewcommand\INPUT{\item[\algorithmicinput]}
\algnewcommand\algorithmicoutput{\textbf{OUTPUT:}}
\algnewcommand\OUTPUT{\item[\algorithmicoutput]}


% Formating Macros

\pagestyle{fancy}
\lhead{\sc \hmwkClass\ $\; \;\cdot \; \;$ \hmwkSemester\ $\; \;\cdot \; \;$
Problem \hmwkAssignmentNum.\hmwkProblemNum}
%\chead{\sc Problem \hmwkAssignmentNum.\hmwkProblemNum}
%\chead{}
\rhead{\em \hmwkAuthorName\ $($\hmwkAuthorID$)$\/}
\cfoot{}
\lfoot{}
\rfoot{\sc Page\ \thepage\ of\ \protect\pageref{LastPage}}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\fancypagestyle{fancycollab}
{
    \lfoot{\textit{Collaborators: \hmwkCollaborators}}
}

\fancypagestyle{problemstatement}
{
    \rhead{}
    \lfoot{}
}

%%%%%% Begin document with header and title %%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%% Header Information %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Shouldn't need to change these
\newcommand{\hmwkClass}{CSCI 255}
\newcommand{\hmwkSemester}{Spring 2016}

%%% Your name, in standard First Last format
\newcommand{\hmwkAuthorName}{Zhuoming Tan}
%%% Your NetID
\newcommand{\hmwkAuthorID}{ztan}

%%% The problem set number (just the number)
\newcommand{\hmwkAssignmentNum}{2}

%%% The problem number (just the number)
\newcommand{\hmwkProblemNum}{1}

%%% A list of your collaborators' NetIDs, separated by ", ".
%%% You can use a new line ("\\") in the middle to prevent a long
%%% list from overflowing.
\newcommand{\hmwkCollaborators}{Rafael Zuniga}
%%% Sets the collaborator list to appear on the first page
\thispagestyle{fancycollab}


\section{Turtle Graphics}

\subsection{How to compile and run}
Easiest way is to import files to eclipse and run from there.

\subsection{Description of algorithms and data structure}
\paragraph{TurtleTokenizer:} The program stores the whole string command in an instance variable. The method \texttt{nextToken} starts going through every character of the string until it identifies a command. In the case of finding braces, we keep an int variable to keep track of how many open braces there are to make sure there are just as many closing braces. Once the command is determined, it is returned as the next token.

\paragraph{TurtleGraphics:} The \texttt{execute} method creates a TurtleTokenizer object and reads each token one by one. For each token, it stores the first character, the command, into a char object and uses it to decide what the turtle should do. It also stores the numbers following the command character and uses it to move the turtle by that many pixels. In the case of the command 'X', we recursively compute the given block of commands the specified number of times. The \texttt{replaceAction} method takes advantage of regular expressions and the provided ui methods to replace the specified strings.



\subsection{Analysis}

\subsection{How to use test files}

\subsection{Description of test cases}
figure \ref{fig:flower} shows the output of our program for the command X36 
\texttt{\{X4 \{F100 L90\} L10\}}. figure \ref{fig:snowflake} shows the ouput for the 
Snowflake3 file.

\begin{figure}[!htp]
\includegraphics[width=0.3\textwidth]{flowerExample.png}
\caption{Flower.}
\label{fig:flower}
\end{figure}


\begin{figure}[!htp]
\includegraphics[width=0.3\textwidth]{snowFlake3.png}
\caption{Snowflake.}
\label{fig:snowflake}
\end{figure}



\newpage
\section{Anagrams}

\subsection{How to compile and run}
Compilation:
\texttt{javac Anagrams.java}

Execution:
\texttt{java\ Anagrams\ input.txt}

\subsection{Description of algorithms and data structure}
Our program uses a \texttt{HashSet} and an \texttt{ArrayList}. In the \texttt{makeAnagram} method, we determine all possible character choices of the first character in the string, and recursively switch characters in substrings to create anagrams of a string.

\subsection{Analysis}
For the recursive \texttt{makeAnagram} method, the complexity is $O(n!)$, since each layer we push onto the stack, we have one less character to make anagrams, and each step takes exactly the length of the string steps to compute anagrams.


\subsection{How to use test files}
To test our code run Anagrams with the input file and compare it with our reference output:

\texttt{java Anagrams in.txt >> out.txt}

\texttt{diff\ out.txt\ cmp.txt}


\subsection{Description of test cases}
Since number of anagram is growing with $n! $, we only created two test cases, \texttt{abc}, and \texttt{post}. The output was exactly as expected.

%%%%%%% end Solution %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
